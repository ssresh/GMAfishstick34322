import isToday from 'date-fns/isToday';
import isYesterday from 'date-fns/isYesterday'; // Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

/**
 * @func Callback function to be called after delay
 * @delay Delay for debounce in ms
 * @immediate should execute immediately
 * @returns debounced callback function
 */

var debounce = function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = null;
    var args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = window.setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};
/**
 * @name Get contrasting text color
 * @description Get contrasting text color from a text color
 * @param bgColor  Background color of text.
 * @returns contrasting text color
 */


var getContrastingTextColor = function getContrastingTextColor(bgColor) {
  var color = bgColor.replace('#', '');
  var r = parseInt(color.slice(0, 2), 16);
  var g = parseInt(color.slice(2, 4), 16);
  var b = parseInt(color.slice(4, 6), 16); // http://stackoverflow.com/a/3943023/112731

  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';
};
/**
 * @name Get formatted date
 * @description Get date in today, yesterday or any other date format
 * @param date  date
 * @param todayText  Today text
 * @param yesterdayText  Yesterday text
 * @returns formatted date
 */


var formatDate = function formatDate(_ref) {
  var date = _ref.date,
      todayText = _ref.todayText,
      yesterdayText = _ref.yesterdayText;
  var dateValue = new Date(date);
  if (isToday(dateValue)) return todayText;
  if (isYesterday(dateValue)) return yesterdayText;
  return date;
};
/**
 * @name formatTime
 * @description Format time to Hour, Minute and Second
 * @param timeInSeconds  number
 * @returns formatted time
 */


var formatTime = function formatTime(timeInSeconds) {
  var formattedTime = '';

  if (timeInSeconds >= 60 && timeInSeconds < 3600) {
    var minutes = Math.floor(timeInSeconds / 60);
    formattedTime = minutes + " Min";
    var seconds = minutes === 60 ? 0 : Math.floor(timeInSeconds % 60);
    return formattedTime + ("" + (seconds > 0 ? ' ' + seconds + ' Sec' : ''));
  }

  if (timeInSeconds >= 3600 && timeInSeconds < 86400) {
    var hours = Math.floor(timeInSeconds / 3600);
    formattedTime = hours + " Hr";

    var _minutes = timeInSeconds % 3600 < 60 || hours === 24 ? 0 : Math.floor(timeInSeconds % 3600 / 60);

    return formattedTime + ("" + (_minutes > 0 ? ' ' + _minutes + ' Min' : ''));
  }

  if (timeInSeconds >= 86400) {
    var days = Math.floor(timeInSeconds / 86400);
    formattedTime = days + " Day";

    var _hours = timeInSeconds % 86400 < 3600 || days >= 364 ? 0 : Math.floor(timeInSeconds % 86400 / 3600);

    return formattedTime + ("" + (_hours > 0 ? ' ' + _hours + ' Hr' : ''));
  }

  return Math.floor(timeInSeconds) + " Sec";
};
/**
 * @name trimContent
 * @description Trim a string to max length
 * @param content String to trim
 * @param maxLength Length of the string to trim, default 1024
 * @param ellipsis Boolean to add dots at the end of the string, default false
 * @returns trimmed string
 */


var trimContent = function trimContent(content, maxLength, ellipsis) {
  if (content === void 0) {
    content = '';
  }

  if (maxLength === void 0) {
    maxLength = 1024;
  }

  if (ellipsis === void 0) {
    ellipsis = false;
  }

  var trimmedContent = content;

  if (content.length > maxLength) {
    trimmedContent = content.substring(0, maxLength);
  }

  if (ellipsis) {
    trimmedContent = trimmedContent + '...';
  }

  return trimmedContent;
};
/**
 * Function that parses a string boolean value and returns the corresponding boolean value
 * @param {string | number} candidate - The string boolean value to be parsed
 * @return {boolean} - The parsed boolean value
 */


function parseBoolean(candidate) {
  try {
    // lowercase the string, so TRUE becomes true
    var candidateString = String(candidate).toLowerCase(); // wrap in boolean to ensure that the return value
    // is a boolean even if values like 0 or 1 are passed

    return Boolean(JSON.parse(candidateString));
  } catch (error) {
    return false;
  }
}

export { debounce, formatDate, formatTime, getContrastingTextColor, parseBoolean, trimContent };